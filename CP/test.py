(*    | Spy.AugAssign(target, op, value) ->*)
(*        let target_id = translate_expr target in*)
(*        let value_id = translate_expr value in*)
(*        let bin_op = (match op with*)
(*            | Spy.Add -> Spvm.ADD*)
(*            | Spy.Sub -> Spvm.SUB*)
(*            | Spy.Mult -> Spvm.MUL*)
(*            | Spy.Div -> Spvm.DIV*)
(*            | Spy.Mod -> Spvm.MOD*)
(*            | Spy.Pow -> Spvm.POW*)
(*            | _ -> raise (Not_Implemented "Augmented assignment with this operator not implemented")*)
(*        ) in*)
(*        [(new_label(), Spvm.ASSIGNV(target_id, bin_op, target_id, value_id))]*)
(*    | Spy.For(target, iter_expr, body) ->*)
(*        let iter = new_temp_var() in (* create a new iterator variable *)*)
(*        let loop_start = new_label() in (* create a label for the start of the loop *)*)
(*        let loop_end = new_label() in (* create a label for the end of the loop *)*)
(*        (* assign the iterator to the iter variable *)*)
(*        let iter_assign = (label_of_string "iter_assign", Spvm.ASSIGNV(iter, NOP, translate_expr iter_expr, "") ) in*)
(*        (* create a while loop that checks if the iterator has a next element *)*)
(*        let while_loop = (label_of_string "while_loop", Spvm.CJUMPF(iter, loop_end) ) :: (translate_stmts body) in*)
(*        (* increment the iterator at the end of each iteration *)*)
(*        let iter_inc = (label_of_string "iter_inc", Spvm.CALL(iter, "next", []) ) in*)
(*        (* combine the instructions into a labeled instruction list *)*)
(*        [(loop_start, iter_assign)] @ while_loop @ [(iter_inc, Spvm.UJUMP(loop_start)), (loop_end, Spvm.SKIP)]*)
(*    | Spy.While()*)

(*    | Spy.List(exprs) ->*)
(*        let tmp1 = new_temp_var() in*)
(*        let cmds1 = List.map (fun expr -> translate_expr expr) exprs in*)
(*        let list_empty_instr = (new_label(), Spvm.LIST_EMPTY tmp1) in*)
(*        list_empty_instr :: (flatten cmds1)*)
(*    | Spy.Tuple(exprs) ->*)
(*        let temp_var = new_temp_var() in*)
(*        let instrs = List.map (fun expr -> translate_expr expr) exprs in*)
(*        let tuple_empty_instr = (new_label(), Spvm.TUPLE_EMPTY temp_var) in*)
(*        let tuple_instrs = List.map (fun expr -> (new_label(), Spvm.TUPLE_INSERT(tmp1, expr))) instrs in*)
(*        tuple_empty_instr :: (flatten tuple_instrs)*)
(*    | Spy.Lambda(args, body) ->*)
(*        let args' = List.map (fun arg -> new_temp_var()) args in*)
(*        let env' = (List.combine args args') @ env in*)
(*        let temp_var = new_temp_var() in*)
(*        let body_instrs = translate_stmt_list env' body tmp1 in*)
(*        let lambda_instr = (new_label(), Spvm.FUNC_DEF(tmp1, args', body_instrs)) in*)
(*        [lambda_instr]*)